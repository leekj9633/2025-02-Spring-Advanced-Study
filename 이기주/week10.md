# 9.3 애플리케이션 아키텍처

아키텍처는 내부 구성요소들의 책임과 방식을 정하고 이를 활용하여 서로 관계를 맺고 동작하는지를 규정하는 것이다. 정의된 구조 안에서 일어나는 동적인 행위와 깊은 관계가 있다.

## 9.3.1 계층형 아키텍처

성격이 다른 모듈이 강하게 결합되어 모여 있으면 변경도 어렵고 오류가 발생할 가능성도 높아진다. 수정에도 쉽지가 않다. 따라서 **인터페이스**와 같은 유연한 겨예를 만들어 분리, 혹은 모아주는 작업이 필요하다.

### 아키텍처와 SoC

아키텍처 레벨에서도 오브젝트의 분리와 DI 등을 적용할 수 있다.
- 예
    - 오브젝트를 하나의 모듈 단위로 생각하거나 더 큰 단위, 혹은 더 작은 단위로 적용하는 것이다.

애플리케이션을 구성하는 오브젝트들을 비슷한 성질끼리 묶을 수 있다.
- 예
    - 데이터 액세스 로직을 담당하는 DAO들은 하나의 단위로 생각할 수 있다.
    - 도메인의 업무와 밀접하게 관련을 갖고 있는 POJO로 만들어지는 경우가 있다.
    - 웹을 처리하는 코드도 묶어서 분류할 수 있다.

애플리케이션의 오브젝트들이 나뉘어 있지 않다면 SQL과 JDBC 등 코드가 얽혀져 있게 된다. 코드를 한 눈에 파악하기도 어렵고 나중에 코드를 리팩토링 할 때 손대기 싫어질 것이다.

따라서 성격이 다른 것은 **아키텍처 레벨**에서 분리하는 것이 좋다. 분리되면 독자적으로 개발과 테스트를 할 수 있어 개발과 변경 작업을 빠르게 처리할 수 있다. 또한, 구현 방법이나 세부 로직도 유연하게 변경 가능하여 이해하기 쉽다.

위와 같이 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 **계층형 아키텍처** 라고 한다. (계층의 의미를 가져와 **멀티 티어 아키텍처 multi tier architecture** 라고도 한다.) 보통 웹 기반의 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖는다고 해서 **3계층 (3-tier 또는 3-layer) 애플리케이션** 이라고도 한다. 3계층으로 만들어야만 하는 것은 아니지만 책임이나 성격으로 분류하자면 일단 3계층의 논리적인 분류가 가능하다.

### 3계층 아키텍처와 수직 계층

🚪 3계층 아키텍처의 구조
1. 데이터 액세스 계층
    - 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할
2. 서비스 계층
    - 비즈니스 로직을 담고 있음
3. 프레젠테이션 계층
    - 주로 웹 기반의 UI를 만들어내고 그 흐름을 관리

#### 데이터 액세스 계층

DAO 패턴을 보편적으로 사용하기 때문에 DAO 계층이라고도 부른다. 대개 장기적인 데이터 저장을 목적으로 하는 *DB 이용*이 주된 책임이다.

사용 기술에 따라서 다시 세분화된 계층으로 구분될 수 있다. 추상화 수준에 따른 구분이기 때문에 *수직적인 계층*이라고 부르기도 한다.

`JdbcTemplate` 을 사용하는 데이터 액세스 계층은 로우레벨의 기반 계층에 존재하는 JDBC와 드라이버, 스프링의 트랜잭션 추상화 서비스의 동기화 기능을 간접적으로 이용하게 만든다. 이 구조를 따른다면 항상 `JdbcTemplate`을 통해 접근하도록 코드를 작서앟는 것이 바람직하다.

다른 방식으로 DAO 코드를 작성하고 싶다면 또 하나의 추상 계층을 추가할 수도 있지만 개발자의 애플리케이션 코드에 큰 영향을 주기 때문에 신중하게 결정하는 것이 좋다. 만약 추상 계층을 새로 추가하는 것이 부담스럽고 하위 계층의 API를 활용할 필요가 있다면, 공통적인 기능을 분리해서 오브젝트 등으로 제공해주는 것이 좋다.

#### 서비스 계층

가장 단순한 구조를 가지고 있다. 잘 만들어진 서비스 계층 클래스는 이상적인 POJO로 작성된다. POJO로 만든다면 비즈니스 로직의 핵심을 잘 담아내서 쉽게 테스트하고 유연하게 확장할 수 있다. 서비스 계층은 DAO 계층을 호출하고 활용해서 만들어진다. 개발자가 원하는 목적에 따라서 3계층 어디서나 접근할 수 있도록 만들 수도 있고, 서비스 계층에서만 사용되도록 제한할 수도 있다.

기반 서비스 계층을 3계층 어디서나 접근이 가능한 구조라고 가정해보고 설명하겠다. *기반 서비스 계층*이 서비스 계층의 오브젝트를 호출하는 경우가 존재할 수 있는데, 일반적으로는 *서비스 계층*이 기반 서비스 계층의 API를 호출하는 경우가 대부분이다. 전자의 경우는 미리 정해진 시간에 특정 서비스 계층의 로직이 동작하게 만드는 백그라운드 서비스가 필요한 *스케줄링*에서 주로 쓰인다.

원칙적으로는 서비스 계층 코드가 기반 서비스 계층의 구현에 종속되면 안 된다. 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들어서 종속성을 제거해야 한다. 혹은 AOP를 통해 부가기능을 추가하는 방법을 활용하는 방법도 있다.

이상적인 서비스 계층은 백엔드 시스템과 연결되는 다른 두 계층이 바뀌어도 그대로 유지될 수 있어야 한다. 서비스 계층은 도메인의 핵심 비즈니스 로직을 담고 있는 가장 중요한 자산이다.

#### 프레젠테이션 계층

가장 복잡한 계층이다. 매우 다양한 기술과 프레임워크의 조합을 가질 수 있기 때문이다. 따라서 이 계층에서 사용할 기술, 구조를 선택하는 것은 어려운 일이다.

프레젠테이션 계층은 방화벽이나 보안 등의 문제로 *HTTP 프로토콜을 사용하는 서블릿*이 바탕이다. 

또한 다른 계층과 달리 클라이언트까지 범위를 확장할 수도 있다. 모든 프레젠테이션 로직은 서버의 프레젠테이션 계층의 컴포넌트에서 처리된다. 화면의 흐름이나 사용자 입력 값에 대한 검증 등이 모두 서버에서 처리됐다. 이때 클라이언트는 사용자 인터페이스에 불과했었지만 최근에는 점점 많은 프레젠테이션 로직이 클라이언트로 이동하고 있다.

### 계층 아키텍처 설계의 원칙

객체지향 설계의 원칙은 아키텍처 레벨의 계층 사이에도 동일하게 적용된다. 각 계층은 자기 역할에 집중하여 **응집도를 높여**야 하며, 다른 계층과는 최소한의 연결 고리만 유지하여 **결합도를 낮춰**야 한다.

🚪 계층 간의 낮은 결합도를 유지하는 방법
1. 구현 기술의 은닉
    - 데이터 액세스 계층(DAO)에서 사용하는 기술(JDBC, JPA 등)이 서비스 계층에 노출되면 안 된다. 예를 들어, `ResultSet`이나 `SQLException` 같은 JDBC 전용 타입을 서비스 계층이 직접 다루게 되면 특정 기술에 강하게 결합되어 유연성이 떨어진다.
2. 추상화된 예외 처리
    - 특정 기술에 종속된 '체크 예외' 대신 스프링의 `DataAccessException`처럼 추상화된 런타임 예외를 사용하여 서비스 계층이 데이터 액세스 기술을 몰라도 되게끔 설계해야 한다.
3. 데이터 전달 오브젝트(DTO/Entity)
    - 계층 사이에서 데이터를 주고받을 때는 특정 기술에 종속되지 않은 단순한 오브젝트(POJO) 형태를 사용해야 한다.

스프링의 DI는 오브젝트 사이의 관계를 맺어주지만, 계층 간의 경계를 자동으로 구분해주지는 않는다. 따라서 개발자가 의도적으로 주의를 기울여야 한다. 중간 계층을 생략하고 멀리 떨어진 계층의 빈(Bean)을 직접 DI 받아 사용하는 것은 피해야 한다. 또한, 특정 계층 내부에서만 사용되도록 설계된 오브젝트가 DI를 통해 다른 계층으로 무분별하게 노출되지 않도록 설계의 원칙을 지켜야 한다.

## 9.3.2 애플리케이션 정보 아키텍처

장기관 보관되는 상태정보는 DB나 메인프레임 같은 백엔드 시스템에 저장되며, 임시 상태정보는 클라이언트에 일시적으로 보관되거나 서버의 사용자별 세션 메모리에 저장된다.

정보를 어떤 식으로 다룰지는 **단순히 데이터로 다루는 경우**와 **오브젝트로 다루는 경우**, 두 가지로 볼 수 있다. 

데이터 중심 아키텍처는 흘러다니는 정보를 단순한 값이나 값을 담기 위한 오브젝트 형태로 취급하는 구조이다. 값으로 다뤄 값을 취급하는 코드로 로직을 구현하고 뷰까지 연결한다. (객체지향 기술, 언어를 사용하지 않을 때와 다르지 않다.)

비즈니스 로직이 DB 내부 저장 프로시저나 SQL에 담겨 있는 경우가 많다. 이 로직을 어디에 두는지에 따라 **DB에 무게를 두는 구조**, **서비스 계층 내 코드에 무게를 두는 구조**로 구분할 수 있다.

### DB/SQL 중심의 로직 구현 방식

데이터 중심 구조의 가장 큰 특징은 *모든 계층의 코드가 하나의 업무 트랜잭션과 SQL에 종속된다*는 점이다. 예를 들어 '사용자 조회'라는 기능이 있다면, SQL이 반환하는 컬럼 구성에 맞춰 DAO, 서비스 계층, 심지어 프레젠테이션 계층(뷰)의 코드까지 1:1로 매핑되어 만들어진다. 결국 모든 계층이 SQL이 어떤 결과를 낼지 이미 알고 있는 상태로 결합하게 된다.

🚪 DB 중심 아키텍처의 문제점
1. 강한 결합과 재사용성 저하
    - 데이터가 계층 사이의 강한 결합을 만든다. 업무 내용이 조금만 바뀌어도 모든 계층의 코드를 함께 수정해야 하며, 유사한 기능이라도 출력 항목이 다르면 새로운 SQL과 DAO 메서드를 만들어야 하므로 코드 중복이 발생한다.
2. 객체지향 장점의 상실
    - 자바 오브젝트는 단지 DB와 웹 화면을 잇는 단순한 인터페이스 도구로 바뀌어, JDBC를 이용한 스크립트 언어 정도의 역할만 수행하게 된다.
3. 테스트와 검증의 어려움
    - SQL이나 저장 프로시저에 담긴 로직은 단위 테스트를 작성하기가 매우 힘들고 번거롭다.

따라서 복잡한 비즈니스 로직을 DB(SQL)가 아닌 애플리케이션 서버의 오브젝트 내부에서 처리해야 한다.

비용과 확장성 측면에서 DB는 확장(Scale-out)에 한계가 있고 비용이 매우 많이 들지만, 애플리케이션 서버는 저렴한 비용으로 쉽게 증설하고 클러스터로 묶어 확장할 수 있다. 또한, 오브젝트에 로직을 담으면 코드를 검증하기 쉽고 안정성이 높아진다. 또한 객체지향 분석과 모델링의 결과를 곧바로 코드로 구현할 수 있어 변화에 유연하게 대응할 수 있다.

### 거대한 서비스 계층 방식

저장 프로시저와 복잡한 SQL을 피하면서, 주요 로직은 서비스 계층의 코드에서 처리하도록 만드는 방식이다. 많은 비즈니스 로직을 DB의 저장 프로시저나 SQL에서 서비스 계층의 오브젝트로 옮겨와서 애플리케이션 코드의 비중이 커진다. 그래도 구조는 단순하고 객체지향 개발의 장점을 살릴 수 있다.

위와 같은 경우 항상 최종 결과만 DAO에서 서비스 계층으로 전달된다. **거대 서비스 계층 방식**에서는 DAO에서 좀 더 단순한 결과를 돌려준다. 서비스 계층 코드의 책임은 DAO가 준 정보를 비즈니스 로직을 적용하는 것이다.

업무 트랜잭션 단위로 서비스 계층의 메소드가 만들어지면 하나의 메소드가 매우 거대해지기도 한다. 여러 메소드로 분산시켜도 전체 클래스 코드의 양은 그대로다. 이렇게 되면 비즈니스 로직의 대부분을 서비스 계층에 집중하는 **거대 서비스 계층**이 만들어지게 되는 것이다.

🚪 거대 서비스 계층 방식의 장점
- 자바 언어의 장점을 활용해 로직 구현 가능, 테스트도 수월
    - 애플리케이션의 코드에 비즈니스 로직이 담겨 있기 때문이다.
- 일부 DAO 코드는 여러 비즈니스 로직에서 공유해서 사용할 수 있다.
    - DAO가 다루는 SQL이 복잡하지 않고 프레젠테이션 계층의 뷰와 1:1로 매핑하지 않아도 되기 때문이다.

🚪 거대 서비스 계층 방식의 단점
- 비슷한 기능의 코드가 여러 메소드에서 중복돼서 나타나기 쉽다.
    - 해당 계층 내의 메소드는 크기가 큰 업무 트랜잭션 단위로 만들어지기 때문이다.
    - 공통 기능으로 뽑아낼 수는 있지만 일반화하기 힘들다.
        - DAO가 제공해주는 값의 포맷에 따라 취급하는 방법이 달라지기 때문이다.

## 9.3.3 오브젝트 중심 아키텍처

오브젝트 중심 아키텍처는 도메인 모델을 반영하는 오브젝트 구조를 만들어두고 이를 각 계층 사이에서 정보 전송 시 사용한다. 도메인 모델 (객체지향 분석과 모델링의 결과) 을 오브젝트 모델로 활용하며, 도메인 모델은 관계형 DB의 엔티티 구조와 유사한 형태일 가능성이 높다.

### 데이터와 오브젝트

복잡한 비즈니스 로직은 DB가 아닌 애플리케이션의 오브젝트에 담아야 한다. 애플리케이션 서버는 DB에 비해 확장 비용이 저렴하고, 오브젝트로 구현된 로직은 검증과 테스트가 훨씬 쉽기 때문이다.

🚪 데이터 중심 방식의 문제점: SQL 종속성
1. 2차원 구조의 한계
    - DB 테이블은 외래키(FK)를 통해 관계를 맺으며, 조회 시 JOIN을 사용해 데이터를 2차원 평면 구조로 가져온다.
2. 유연성 부족
    - DAO에서 SQL 결과를 `Map`이나 `List`에 담아 넘기면, 서비스 계층은 그 안에 어떤 필드가 있는지(키 값 등)를 상세히 알고 있어야 한다.
3. 강한 결합
    - SQL이 변경되면 이를 사용하는 서비스 계층과 프레젠테이션 계층의 코드도 줄줄이 변경되어야 하며, 데이터의 원래 관계 정보가 사라진 채 단순한 결과 값만 주고받는다.

🚪 SQL 실행 결과를 맵에 담는 DAO 코드
```java
while(rs.next()) {
    Map<String, Object> resMap = new HashMap<String, Object>();
    resMap.put("categoryId", rs.getString(1));
    resMap.put("description", rs.getString(2));
    ...
    list.add(resMap);
}
```

🚪 오브젝트 중심 방식: 도메인 모델의 활용
1. 상호 참조 가능 
    - 오브젝트는 레퍼런스 변수를 통해 서로를 직접 가리킨다. 예를 들어 `Product`는 자신을 포함하는 `Category`를 참조하고, `Category`는 자신에게 속한 `Product`들을 `Set` 같은 컬렉션으로 가질 수 있다.
2. 일관된 구조
    - 도메인 모델이 반영된 오브젝트는 애플리케이션 전 계층에서 동일한 의미를 갖는다. SQL 결과 포맷에 종속되지 않으므로 훨씬 자유롭게 정보를 다룰 수 있다.
3. 계층 간 독립성
    - DAO가 데이터를 도메인 오브젝트에 담아주면, 서비스 계층은 DAO가 어떤 SQL을 썼는지 알 필요 없이 오브젝트의 정보를 활용해 비즈니스 로직만 처리하면 된다.

🚪 도메인 오브젝트
```java
public class Category {
    int categoryid;
    String description;     // 0~N개의 Product를 참조하고 있는 컬렉션 가질 수 있음
    Set<Product> products; 
    
    // Getter, Setter...
}

public class Product {
    int productid;
    String name;
    int price;
    
    Category category;     // 자신이 속한 Category를 직접 참조하는 레퍼런스 변수
    
    // Getter, Setter...
}
```

### 도메인 오브젝트를 사용하는 코드

오브젝트 중심 방식에서 비즈니스 로직 구현의 간단함을 살펴보자. 아래 코드에서는 어떤 카테고리에 포함된 상품의 모든 가격을 계산해야 하는 로직을 메소드로 구현했다. 어떻게든 `Category` 오브젝트를 가지고 있다면 `calcTotalOfProductPrice()` 로 모든 상품 가격의 합을 계산할 수 있다.

자바에서는 '.'을 사용해 레퍼런스 변수를 따라가면 ` product.getCategory().getProducts().size()` 이렇게 관련 정보를 손쉽게 이용할 수 있다.

🚪 `Category` 오브젝트를 사용하는 메소드
```java
public int calcTotalOfProductPrice(Category cate){
    int sum = 0;
    for (Product prd : cate.getProducts()){   // Category는 도메인 모델로 만들어진 오브젝트이므로 Category에 포함된 모든 Product 가져오기 가능
        sum += prd.getPrice();
    }
    return sum;
}
```

만약 데이터 중심 방식이었다면, DAO에서 여러 개의 `Category`와 `Product`를 조인해서 가져왔다면 별도의 합계 계산 코드를 만들어야 한다는 불편한 점이 발생한다. 

### 도메인 오브젝트 사용의 문제점

도메인 모델을 따르는 오브젝트를 사용하면 이해하기 쉽고 재사용성이 높다는 장점이 있지만, 성능과 최적화 면에서 단점도 존재한다.

- 성능 및 낭비 문제
    - DAO는 비즈니스 로직에서 정확히 어떤 필드가 필요한지 모르기 때문에 대부분 모든 필드 정보를 채워서 전달하는데 이 과정에서 필요 없는 데이터까지 조회하게 되는 낭비가 발생할 수 있다.
- 연관 오브젝트 조회 문제
    - 특정 정보(예: Product)만 필요함에도 연관된 정보(예: Category)까지 모두 조회하여 오브젝트를 만드는 것은 성능상 손해가 될 수 있다.
- 결합도와 예외 위험
    - 최적화를 위해 일부 정보를 누락(null)시키면 `NullPointerException`이 발생할 위험이 커지고, DAO와 비즈니스 로직 사이의 결합도가 다시 높아지는 문제가 생긴다.

이러한 문제들을 해결하기 위한 가장 이상적인 방법은 JPA, 하이버네이트와 같은 ORM(Object-Relational Mapping) 기술을 사용하는 것이다.

🚪 ORM 기술 특징
1. 최소한의 정보만 먼저 읽어두고, 실제로 연관된 오브젝트가 필요한 시점에 다이내믹하게 DB에서 읽어오는 기능을 제공한다.
2. ORM은 SQL 생성 코드를 줄여줄 뿐만 아니라, 내부적인 최적화 및 오브젝트 캐시를 통해 DB 부하를 줄여 성능을 크게 향상시킨다.
3. JDBC를 직접 사용할 때 발생하는 코드 중복과 계층 간 결합도를 최소화하면서도 일관된 정보 모델을 유지할 수 있어 개발 생산성과 테스트 편의성이 높아진다.

### 빈약한 도메인 오브젝트 방식

빈약한 오브젝트란?

도메인 오브젝트에 정보만 담겨있고, 이를 활용하는 기능은 가지고 있지 않은 것.

도메인 오브젝트를 전혀 사용하지 않는 것보다는 훨씬 낫다. 그래서 **특정 계층에 종속되지 않으**면서 애플리케이션 전반에서 **사용될 수 있는 정보를 담은 오브젝트**가 필요하여 실제로 종종 사용된다.

도메인 오브젝트에 넣을 수 있는 기능은 도메인 비즈니스 로직이라고 볼 수 있다. 이 비즈니스 로직은 서비스 계층에 존재한다. 빈약한 도메인 오브젝트 방식은 데이터 중심 아키텍처의 거대 서비스 계층구조와 비슷하다.

비즈니스 로직이 복잡하지 않다면 가장 만들기 쉽고 3계층 구조의 특징을 살려서 개발할 수 있는 유용한 아키텍처다.

### 풍성한 도메인 오브젝트 방식

빈약한 도메인 오브젝트(단순히 데이터만 담는 경우)의 단점을 극복하기 위해, 비즈니스 로직을 도메인 오브젝트 내부에 직접 구현하는 방식이다. 데이터와 그 데이터를 사용하는 **기능을 한곳에 모아둠**으로써 코드의 **응집도**가 높아진다. 또한, 서비스 계층에서 다른 서비스를 DI 받아 복잡하게 호출하는 대신, 도메인 오브젝트에 **필요한 계산을 직접 요청**하면 코드가 훨씬 직관적이고 간결해진다.

🚪 기존 방식: 다른 서비스의 로직을 DI 받아 사용하는 경우
```java
public class InventoryService {
    private CategoryService categoryService;

    public void setCategoryService(CategoryService categoryService) {
        this.categoryService = categoryService;
    }

    public void complexInventoryAnalysis() {
        // 계산 로직을 위해 Category 정보를 파라미터로 전달하며 서비스를 호출
        int total = this.categoryService.calcTotalOfProductPrice(category);
    }
}
```

🚪 개선 방식: 자체 로직을 가진 도메인 오브젝트 활용
```java
// 서비스 계층 (InventoryService.java)
public class InventoryService {
    public void complexInventoryAnalysis() {
        // 별도의 서비스 DI 없이 도메인 오브젝트에 직접 요청 (훨씬 객체지향적임)
        int total = category.calcTotalOfProductPrice();
    }
}
```

도메인 오브젝트와 서비스 계층 한 쪽에 치우쳐서는 안 된다. 따라서 역할에 따른 적절한 분리가 필요하다.

- 도메인 오브젝트의 역할
    - 해당 오브젝트의 **정보**와 긴밀한 연관 관계를 맺고 있는 데이터의 수식 계산, 조건 분석 등의 로직을 담당한다. 하지만 도메인 오브젝트는 스프링의 빈이 아니므로 **DAO나 다른 서비스를 DI 받아 사용할 수 없다.**
- 서비스 계층의 역할
    - DB 저장, 메일 발송, 외부 시스템 연동 등 DAO나 외부 리소스를 활용해야 하는 **복잡한 비즈니스 로직**을 담당한다. 도메인 오브젝트들을 조합하여 **전체적인 업무 흐름을 제어**하는 역할을 수행한다.

### 도메인 계층 방식

비즈니스 로직이 매우 복잡하고 변경이 잦은 도메인이라면, 도메인 오브젝트가 기존 3계층(프레젠테이션, 서비스, 데이터 액세스)과 동등한 수준의 독립적인 계층을 이루는 도메인 계층 방식을 채택한다.

🚪 도메인 계층의 특징
1. 독립적인 생명주기: 서비스(싱글톤)와 달리 각 요청마다 생성되어 로직을 처리하고 소멸한다.
2. 상태 유지: 사용자별 요청에 대해 독립적인 상태 정보를 담고 있어 스레드 간 공유가 불가능하다.
3. 로직의 위임: 서비스 계층은 트랜잭션 경계 설정이나 기반 서비스 이용 등 보조적인 역할만 수행하고, 핵심 로직은 도메인 계층이 담당한다.

스프링 AOP 대신 **AspectJ AOP**를 사용하면, 스프링이 관리하지 않는 일반 오브젝트(생성자로 만들어지는 시점)에도 의존관계를 주입할 수 있다. 이를 통해 도메인 오브젝트가 직접 데이터 액세스 계층의 기능을 활용할 수 있게 된다.

또 다른 방법으로는 도메인 오브젝트의 핵심 로직이 프레젠테이션 계층에서 함부로 노출되거나 실행되는 것을 막기 위해, 계층 밖으로 나갈 때는 데이터를 복사한 **DTO**를 사용한다.

## 9.3.4 스프링 애플리케이션을 위한 아키텍처 설계

### 계층형 아키텍처

**SOFEA 아키텍처**
최근에는 프레젠테이션 계층의 코드가 서버를 떠나 클라이언트(브라우저 등)까지 확장되는 *SOFEA(Service Oriented Front End Architecture) 방식*이 성장하고 있다. SOFEA는 사용자 인터페이스, 화면 제어, 상태 정보 유지 등을 클라이언트에 다운로드된 코드에서 담당한다. 서버에 존재하는 서비스 계층과 통신하며 전통적인 MVC 패턴의 위치를 위협할 만큼 빠르게 성장하고 있다.

3계층 구조는 엔터프라이즈 애플리케이션의 기본이지만, 반드시 고정된 것은 아니다. 로직이 단순한 경우 서비스 계층과 데이터 액세스 계층을 통합하여 DAO에 간략한 로직을 담을 수 있다. 같은 오브젝트에 담겨 있더라도 비즈니스 로직과 데이터 액세스 로직은 독립적인 메소드로 분리하는 것이 좋다.

### 상태 관리와 빈 스코프

하나의 애플리케이션이 수많은 사용자의 요청을 동시에 처리하기 위해 매번 요청을 받고 결과를 돌려주는 방식으로 동작한다. 그래서 서버 자원이 지속적으로 유지되는 상태를 갖지 않는다. 클라이언트로부터 요청을 처리할 때만 도메인 오브젝트와 같은 정보저장소에 현재 상태정보가 보관되지만, 결과를 돌려주고 나면 바로 폐기된다.

장시간 진행되는 작업정보를 유지하기 위해서는 웹 클라이언트에 *URL, 파라미터, 폼 히든 필드, 쿠키* 등을 이용해서 키 값 등을 전달한다. 

이렇게 상태를 저장, 유지하는 데 쓰이는 방식을 결정하는 일은 매우 중요하다. 기본적으로는 상태가 유지되지 않는 *빈, 오브젝트*를 사용하는 것을 권장한다. 이 둘은 개발하기 쉽고 서버를 확장하기 쉽기 때문이다.

웹 클라이언트에 폼 정보를 출력, 수정을 하기 위해서는 *HTTP 세션* 이 좋다. 여러 번의 HTTP 요청을 걸쳐 일어나기 때문에 편하기 때문이다.

### 서드파티 프레임워크, 라이브러리 적용

스프링은 다양한 표준 기술(J2EE) 및 오픈소스 프레임워크와 유연하게 결합된다. 새로운 기술을 연동할 때는 아래 네 가지 원칙을 따른다.

1. DI 패턴 적용: 핵심 클래스를 스프링 빈으로 등록하여 다른 오브젝트에서 손쉽게 활용할 수 있게 한다.
2. 서비스 추상화: 다양한 기술에 대해 일관된 접근 방법을 정의하여 필요시 기술을 손쉽게 교체할 수 있게 한다.
3. 프로그래밍 모델 준수: 일관된 예외 처리와 런타임 위주의 예외 구조를 따라 불필요한 코드를 줄인다.
4. 템플릿/콜백 지원: 반복되는 코드를 제거하고 추상화하기 어려운 구조를 간편하게 사용할 수 있도록 지원한다.